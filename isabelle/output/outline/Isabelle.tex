%
\begin{isabellebody}%
\setisabellecontext{Isabelle}%
%
\isadelimtheory
%
\endisadelimtheory
%
\isatagtheory
%
\endisatagtheory
{\isafoldtheory}%
%
\isadelimtheory
%
\endisadelimtheory
%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupchapter{Isabelle%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
\label{chap:isabelle}%
\end{isamarkuptext}\isamarkuptrue%
%
\begin{isamarkuptext}%
Isabelle is an interactive proof assistant and Isabelle/HOL is an implementation of \emph{higher-order logic} in Isabelle. With it, one can interactively prove propositions about theories that are formalised in terms of higher-order logic. Many theories have been formalised (and many theorems proven) in Isabelle/HOL and are publicly available.\footnote{see Isabelle's Archive of Formal Proofs at \code{\href{https://www.isa-afp.org}{isa-afp.org}}}

In this appendix, I will give a short introduction into the most important concepts of Isabelle. For an extensive tutorial, see \cite{prog_prove}. A complete documentation can be found in \cite{isar_ref}.

All formalisations are based on Isabelle/HOL, allowing us to use e.g.\@ quantifiers \isa{{\isasymforall}} and \isa{{\isasymexists}}.%
\end{isamarkuptext}\isamarkuptrue%
%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsubsubsection{Simple Definitions%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
The command \isa{definition} defines a term by establishing an equality, denoted by \isa{{\isasymequiv}}. This term can be a function or a constant (i.e.\@ 0-ary function). Predicates are functions to Boolean values.

Definitions are annotated by their type. As an example, we define the predicate \isa{even}, which maps an integer to a Boolean value.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{definition}\isamarkupfalse%
\ even\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isacartoucheopen}int\ {\isasymRightarrow}\ bool{\isacartoucheclose}\isanewline
\ \ \isakeyword{where}\ {\isacartoucheopen}even\ n\ {\isasymequiv}\ {\isasymexists}\ m{\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}int\ {\isachardot}{\kern0pt}\ n\ {\isacharequal}{\kern0pt}\ {\isadigit{2}}\ {\isacharasterisk}{\kern0pt}\ m{\isacartoucheclose}%
\begin{isamarkuptext}%
Functions can be defined in uncurried form (e.g.\@ \isa{{\isacharparenleft}{\kern0pt}int\ {\isasymtimes}\ int{\isacharparenright}{\kern0pt}\ {\isasymRightarrow}\ bool}) or in curried form (e.g.\@ \isa{int\ {\isasymRightarrow}\ int\ {\isasymRightarrow}\ bool}). As a very trivial example, we can define equality predicates for integers. Compared to the curried version, the uncurried version does not allow for easy pattern matching. This is why, in this thesis, I will usually specify functions in curried form.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{definition}\isamarkupfalse%
\ equal{\isacharunderscore}{\kern0pt}uncurried\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isacartoucheopen}{\isacharparenleft}{\kern0pt}int\ {\isasymtimes}\ int{\isacharparenright}{\kern0pt}\ {\isasymRightarrow}\ bool{\isacartoucheclose}\isanewline
\ \ \isakeyword{where}\ {\isacartoucheopen}equal{\isacharunderscore}{\kern0pt}uncurried\ pair\ {\isasymequiv}\ {\isasymexists}\ n\ m{\isachardot}{\kern0pt}\ pair\ {\isacharequal}{\kern0pt}\ {\isacharparenleft}{\kern0pt}n{\isacharcomma}{\kern0pt}\ m{\isacharparenright}{\kern0pt}\ {\isasymand}\ n\ {\isacharequal}{\kern0pt}\ m{\isacartoucheclose}\isanewline
\isanewline
\isacommand{definition}\isamarkupfalse%
\ equal{\isacharunderscore}{\kern0pt}curried\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isacartoucheopen}int\ {\isasymRightarrow}\ int\ {\isasymRightarrow}\ bool{\isacartoucheclose}\isanewline
\ \ \isakeyword{where}\ {\isacartoucheopen}equal{\isacharunderscore}{\kern0pt}curried\ n\ m\ {\isasymequiv}\ n\ {\isacharequal}{\kern0pt}\ m{\isacartoucheclose}%
\begin{isamarkuptext}%
We can also use type variables (prefixed with an apostrophe, e.g.\@ \isa{{\isacharprime}{\kern0pt}a}) instead of concrete types to get more abstract terms.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{definition}\isamarkupfalse%
\ equal{\isacharunderscore}{\kern0pt}abstract\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isacartoucheopen}{\isacharprime}{\kern0pt}a\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ {\isasymRightarrow}\ bool{\isacartoucheclose}\isanewline
\ \ \isakeyword{where}\ {\isacartoucheopen}equal{\isacharunderscore}{\kern0pt}abstract\ a\ b\ {\isasymequiv}\ a\ {\isacharequal}{\kern0pt}\ b{\isacartoucheclose}%
\begin{isamarkuptext}%
For a less trivial example, we define a predicate \isa{symmetric} that determines whether a given relation is symmetric. An arbitrary homogeneous relation in curried form has the type \isa{{\isacharprime}{\kern0pt}a\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ {\isasymRightarrow}\ bool}.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{definition}\isamarkupfalse%
\ symmetric\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isacartoucheopen}{\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ {\isasymRightarrow}\ bool{\isacharparenright}{\kern0pt}\ {\isasymRightarrow}\ bool{\isacartoucheclose}\isanewline
\ \ \isakeyword{where}\ {\isacartoucheopen}symmetric\ R\ {\isasymequiv}\ {\isasymforall}\ a\ b{\isachardot}{\kern0pt}\ R\ a\ b\ {\isasymlongrightarrow}\ R\ b\ a{\isacartoucheclose}%
\begin{isamarkuptext}%
We can also assign notation to a term during the definition, where \isa{{\isacharunderscore}{\kern0pt}} is a placeholder (and the numbers behind the notation specification represent priorities for parsing, which may be ignored by the reader).%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{definition}\isamarkupfalse%
\ approx\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isacartoucheopen}int\ {\isasymRightarrow}\ int\ {\isasymRightarrow}\ bool{\isacartoucheclose}\isanewline
\ \ {\isacharparenleft}{\kern0pt}{\isacartoucheopen}{\isacharunderscore}{\kern0pt}\ {\isasymapprox}\ {\isacharunderscore}{\kern0pt}{\isacartoucheclose}\ {\isacharbrackleft}{\kern0pt}{\isadigit{5}}{\isadigit{0}}{\isacharcomma}{\kern0pt}\ {\isadigit{5}}{\isadigit{0}}{\isacharbrackright}{\kern0pt}\ {\isadigit{5}}{\isadigit{0}}{\isacharparenright}{\kern0pt}\isanewline
\ \ \isakeyword{where}\ {\isacartoucheopen}n\ {\isasymapprox}\ m\ {\isasymequiv}\ n{\isacharequal}{\kern0pt}m{\isacharminus}{\kern0pt}{\isadigit{1}}\ {\isasymor}\ n{\isacharequal}{\kern0pt}m\ {\isasymor}\ n{\isacharequal}{\kern0pt}m{\isacharplus}{\kern0pt}{\isadigit{1}}{\isacartoucheclose}%
\begin{isamarkuptext}%
Abbreviations are used the same way as definitions, except that, in order to use the equality established by definitions in proofs, we need to explicitly refer to the definition, whereas abbreviations are always expanded by the proof system. An example a little further down below should clarify the distinction.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{abbreviation}\isamarkupfalse%
\ reflexive\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isacartoucheopen}{\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a\ {\isasymRightarrow}\ {\isacharprime}{\kern0pt}a\ {\isasymRightarrow}\ bool{\isacharparenright}{\kern0pt}\ {\isasymRightarrow}\ bool{\isacartoucheclose}\isanewline
\ \ \isakeyword{where}\ {\isacartoucheopen}reflexive\ R\ {\isasymequiv}\ {\isasymforall}\ a{\isachardot}{\kern0pt}\ R\ a\ a{\isacartoucheclose}%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsubsubsection{Proving Propositions%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
Propositions are terms of Boolean type. Propositions can be given using any of the commands \isa{proposition}, \isa{lemma}, \isa{theorem}, \isa{corollary}, and require a proof.

Since Isabelle is an \emph{interactive} proof assistant, proofs are usually meant to be spelled out in code so as to be readable by humans, and the validity of individual steps is verified by certain automated proof methods (e.g.\@ \isa{simp}, \isa{arith}, \isa{auto}, \isa{fast}, \isa{blast}, \dots). 

As an example, we will show that the relation \isa{approx} is \isa{symmetric}.

Since \isa{symmetric} was defined using the command \isa{definition}, we need to explicitly unfold it, where \isa{symmetric{\isacharunderscore}{\kern0pt}def} is the fact (about the equality) introduced by the definition.

The method specified after the command \isa{proof} adjusts the proof goal in some way. Ideally, the proof steps should be clear to the reader even without seeing what exactly the automated methods are doing. I have explained each of the steps using comments below.%
\end{isamarkuptext}\isamarkuptrue%
%
\isadelimvisible
%
\endisadelimvisible
%
\isatagvisible
\isacommand{proposition}\isamarkupfalse%
\ {\isacartoucheopen}symmetric\ approx{\isacartoucheclose}\isanewline
\ \ \isacommand{unfolding}\isamarkupfalse%
\ symmetric{\isacharunderscore}{\kern0pt}def\isanewline
\isacommand{proof}\isamarkupfalse%
\ {\isacharparenleft}{\kern0pt}clarify{\isacharparenright}{\kern0pt}\isanewline
\ \ %
\isamarkupcmt{We want to show that for any \isa{n} and \isa{m} with \isa{n\ {\isasymapprox}\ m}, we have \isa{m\ {\isasymapprox}\ n}.%
}\isanewline
\ \ \isacommand{fix}\isamarkupfalse%
\ n\ m\isanewline
\ \ \isacommand{assume}\isamarkupfalse%
\ {\isacartoucheopen}n\ {\isasymapprox}\ m{\isacartoucheclose}\isanewline
\ \ %
\isamarkupcmt{Using the definition of \isa{approx}, we now this about \isa{n} and \isa{m}.%
}\isanewline
\ \ \isacommand{hence}\isamarkupfalse%
\ {\isacartoucheopen}n{\isacharequal}{\kern0pt}m{\isacharminus}{\kern0pt}{\isadigit{1}}\ {\isasymor}\ n{\isacharequal}{\kern0pt}m\ {\isasymor}\ n{\isacharequal}{\kern0pt}m{\isacharplus}{\kern0pt}{\isadigit{1}}{\isacartoucheclose}\ \isacommand{unfolding}\isamarkupfalse%
\ approx{\isacharunderscore}{\kern0pt}def\ \isacommand{{\isachardot}{\kern0pt}}\isamarkupfalse%
\isanewline
\ \ \isacommand{thus}\isamarkupfalse%
\ {\isacartoucheopen}m\ {\isasymapprox}\ n{\isacartoucheclose}\isanewline
\ \ %
\isamarkupcmt{With disjunction elimination, we examine each case in a sub-proof.%
}\isanewline
\ \ \isacommand{proof}\isamarkupfalse%
\ {\isacharparenleft}{\kern0pt}elim\ disjE{\isacharparenright}{\kern0pt}\isanewline
\ \ \ \ \isacommand{assume}\isamarkupfalse%
\ {\isacartoucheopen}n\ {\isacharequal}{\kern0pt}\ m\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacartoucheclose}\isanewline
\ \ \ \ \isacommand{hence}\isamarkupfalse%
\ {\isacartoucheopen}m\ {\isacharequal}{\kern0pt}\ n\ {\isacharplus}{\kern0pt}\ {\isadigit{1}}{\isacartoucheclose}\ \isacommand{by}\isamarkupfalse%
\ arith\isanewline
\ \ \ \ \isacommand{thus}\isamarkupfalse%
\ {\isacartoucheopen}m\ {\isasymapprox}\ n{\isacartoucheclose}\ \isacommand{unfolding}\isamarkupfalse%
\ approx{\isacharunderscore}{\kern0pt}def\ \isacommand{by}\isamarkupfalse%
\ blast\isanewline
\ \ \isacommand{next}\isamarkupfalse%
\isanewline
\ \ \ \ \isacommand{assume}\isamarkupfalse%
\ {\isacartoucheopen}n\ {\isacharequal}{\kern0pt}\ m{\isacartoucheclose}\isanewline
\ \ \ \ \isacommand{thus}\isamarkupfalse%
\ {\isacartoucheopen}m\ {\isasymapprox}\ n{\isacartoucheclose}\ \isacommand{using}\isamarkupfalse%
\ approx{\isacharunderscore}{\kern0pt}def\ \isacommand{by}\isamarkupfalse%
\ blast\isanewline
\ \ \isacommand{next}\isamarkupfalse%
\isanewline
\ \ \ \ \isacommand{assume}\isamarkupfalse%
\ {\isacartoucheopen}n\ {\isacharequal}{\kern0pt}\ m\ {\isacharplus}{\kern0pt}\ {\isadigit{1}}{\isacartoucheclose}\isanewline
\ \ \ \ \isacommand{hence}\isamarkupfalse%
\ {\isacartoucheopen}m\ {\isacharequal}{\kern0pt}\ n\ {\isacharminus}{\kern0pt}\ {\isadigit{1}}{\isacartoucheclose}\ \isacommand{by}\isamarkupfalse%
\ arith\isanewline
\ \ \ \ \isacommand{thus}\isamarkupfalse%
\ {\isacartoucheopen}m\ {\isasymapprox}\ n{\isacartoucheclose}\ \isacommand{using}\isamarkupfalse%
\ approx{\isacharunderscore}{\kern0pt}def\ \isacommand{by}\isamarkupfalse%
\ blast\isanewline
\ \ \isacommand{qed}\isamarkupfalse%
\isanewline
\isacommand{qed}\isamarkupfalse%
%
\endisatagvisible
{\isafoldvisible}%
%
\isadelimvisible
%
\endisadelimvisible
%
\begin{isamarkuptext}%
This proof was probably more detailed than was necessary. By unfolding the other definition as well, this proposition can be proven directly with the proof method \isa{arith}.%
\end{isamarkuptext}\isamarkuptrue%
%
\isadelimvisible
%
\endisadelimvisible
%
\isatagvisible
\isacommand{proposition}\isamarkupfalse%
\ {\isacartoucheopen}symmetric\ approx{\isacartoucheclose}\isanewline
\ \ \isacommand{unfolding}\isamarkupfalse%
\ symmetric{\isacharunderscore}{\kern0pt}def\ approx{\isacharunderscore}{\kern0pt}def\ \isacommand{by}\isamarkupfalse%
\ arith%
\endisatagvisible
{\isafoldvisible}%
%
\isadelimvisible
%
\endisadelimvisible
%
\begin{isamarkuptext}%
To see the difference between definitions and abbreviations, note that the following proposition is provable without unfolding \isa{reflexive{\isacharunderscore}{\kern0pt}def} (since \isa{reflexive} is an abbreviation, there is no such fact in this context).%
\end{isamarkuptext}\isamarkuptrue%
%
\isadelimvisible
%
\endisadelimvisible
%
\isatagvisible
\isacommand{proposition}\isamarkupfalse%
\ {\isacartoucheopen}reflexive\ approx{\isacartoucheclose}\isanewline
\ \ \isacommand{unfolding}\isamarkupfalse%
\ approx{\isacharunderscore}{\kern0pt}def\ \isacommand{by}\isamarkupfalse%
\ auto%
\endisatagvisible
{\isafoldvisible}%
%
\isadelimvisible
%
\endisadelimvisible
%
\begin{isamarkuptext}%
In practice, of course, one has to strike a balance between transparency/comprehensibility and conciseness of proofs.%
\end{isamarkuptext}\isamarkuptrue%
%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsubsubsection{Inductive Definitions%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
Inductively defined predicates can be given using premise-conclusion pairs and multiple clauses.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{inductive}\isamarkupfalse%
\ even{\isacharunderscore}{\kern0pt}ind\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isacartoucheopen}int\ {\isasymRightarrow}\ bool{\isacartoucheclose}\isanewline
\ \ \isakeyword{where}\isanewline
\ \ \ \ {\isacartoucheopen}even{\isacharunderscore}{\kern0pt}ind\ {\isadigit{0}}{\isacartoucheclose}\isanewline
\ \ {\isacharbar}{\kern0pt}\ {\isacartoucheopen}even{\isacharunderscore}{\kern0pt}ind\ n\ {\isasymLongrightarrow}\ even{\isacharunderscore}{\kern0pt}ind\ {\isacharparenleft}{\kern0pt}n{\isacharplus}{\kern0pt}{\isadigit{2}}{\isacharparenright}{\kern0pt}{\isacartoucheclose}%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsubsubsection{Function Definitions%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
The command \isa{function} also establishes equalities, but usually in more complex ways, so that, sometimes, it is not obvious whether a function is well-defined. Hence, the command \isa{function} introduces proof obligations to show that the function is, in fact, well-defined. (These proofs are usually easily solved by the automated proof methods.)

The function is then assumed to be partial. The command \isa{termination} introduces proof obligations to show that the function always terminates (and is thus total). For the example below, this proof, again, is trivial.%
\end{isamarkuptext}\isamarkuptrue%
%
\isadelimvisible
%
\endisadelimvisible
%
\isatagvisible
\isacommand{function}\isamarkupfalse%
\ factorial\ {\isacharcolon}{\kern0pt}{\isacharcolon}{\kern0pt}\ {\isacartoucheopen}nat\ {\isasymRightarrow}\ nat{\isacartoucheclose}\isanewline
\ \ \isakeyword{where}\isanewline
\ \ \ \ {\isacartoucheopen}n\ {\isacharequal}{\kern0pt}\ {\isadigit{0}}\ {\isasymLongrightarrow}\ factorial\ n\ {\isacharequal}{\kern0pt}\ {\isadigit{1}}{\isacartoucheclose}\isanewline
\ \ {\isacharbar}{\kern0pt}\ {\isacartoucheopen}n\ {\isachargreater}{\kern0pt}\ {\isadigit{0}}\ {\isasymLongrightarrow}\ factorial\ n\ {\isacharequal}{\kern0pt}\ n\ {\isacharasterisk}{\kern0pt}\ factorial\ {\isacharparenleft}{\kern0pt}n{\isacharminus}{\kern0pt}{\isadigit{1}}{\isacharparenright}{\kern0pt}{\isacartoucheclose}\isanewline
\ \ \isacommand{by}\isamarkupfalse%
\ auto\isanewline
\isanewline
\isacommand{termination}\isamarkupfalse%
\ factorial\ \isacommand{using}\isamarkupfalse%
\ {\isachardoublequoteopen}termination{\isachardoublequoteclose}\ \isacommand{by}\isamarkupfalse%
\ force%
\endisatagvisible
{\isafoldvisible}%
%
\isadelimvisible
%
\endisadelimvisible
%
\begin{isamarkuptext}%
After proving well-definedness and totality, we have access to facts about the function that can be used in proofs, e.g.\@ induction principles. More details can be found in \cref{sec:HML}, when we define our first non-trivial \isa{function}.%
\end{isamarkuptext}\isamarkuptrue%
%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsubsubsection{Data Types%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
With the command \isa{datatype}, new types can be defined, possibly in dependence on existing types, by defining a set of (object) constructor functions. For example, we can (re-)define the type of natural numbers.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{datatype}\isamarkupfalse%
\ natural{\isacharunderscore}{\kern0pt}number\ {\isacharequal}{\kern0pt}\isanewline
\ \ Zero\ %
\isamarkupcmt{0-ary base constructor%
}\isanewline
{\isacharbar}{\kern0pt}\ Suc\ {\isacartoucheopen}natural{\isacharunderscore}{\kern0pt}number{\isacartoucheclose}\ %
\isamarkupcmt{unary recursive/inductive constructor%
}%
\begin{isamarkuptext}%
We can define type constructors, i.e.\@ types depending on other types (to be distinguished from the object constructors above) by parameterising the type with type variables.%
\end{isamarkuptext}\isamarkuptrue%
\isacommand{datatype}\isamarkupfalse%
\ {\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a{\isacharparenright}{\kern0pt}list\ {\isacharequal}{\kern0pt}\isanewline
\ \ Empty\isanewline
{\isacharbar}{\kern0pt}\ Cons\ {\isacartoucheopen}{\isacharprime}{\kern0pt}a{\isacartoucheclose}\ {\isacartoucheopen}{\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a{\isacharparenright}{\kern0pt}list{\isacartoucheclose}\isanewline
%
\isamarkupcmt{binary constructor taking an element of type \isa{{\isacharprime}{\kern0pt}a} and another \isa{{\isacharparenleft}{\kern0pt}{\isacharprime}{\kern0pt}a{\isacharparenright}{\kern0pt}list}%
}%
\isadelimdocument
%
\endisadelimdocument
%
\isatagdocument
%
\isamarkupsubsubsection{Locales%
}
\isamarkuptrue%
%
\endisatagdocument
{\isafolddocument}%
%
\isadelimdocument
%
\endisadelimdocument
%
\begin{isamarkuptext}%
Locales define a context consisting of type variables, object variables, and assumptions. These can be accessed in the entire context. Locales can also be instantiated by specifying concrete types (or type variables from another context) for the type variables, and extended to form new locales. We can reenter the context of a locale later on, using the command \isa{context}.

\Cref{sec:LTS} provides a good example for how locales are used in Isabelle to formalise linear transition systems.%
\end{isamarkuptext}\isamarkuptrue%
%
\isadelimtheory
%
\endisadelimtheory
%
\isatagtheory
%
\endisatagtheory
{\isafoldtheory}%
%
\isadelimtheory
%
\endisadelimtheory
%
\end{isabellebody}%
\endinput
%:%file=~/reactive-bisimilarity-reduction/Isabelle.thy%:%
%:%24=10%:%
%:%36=11%:%
%:%40=13%:%
%:%41=14%:%
%:%42=15%:%
%:%43=16%:%
%:%44=17%:%
%:%53=19%:%
%:%65=21%:%
%:%66=22%:%
%:%67=23%:%
%:%69=25%:%
%:%70=25%:%
%:%71=26%:%
%:%73=28%:%
%:%75=30%:%
%:%76=30%:%
%:%77=31%:%
%:%78=32%:%
%:%79=33%:%
%:%80=33%:%
%:%81=34%:%
%:%83=36%:%
%:%85=38%:%
%:%86=38%:%
%:%87=39%:%
%:%89=41%:%
%:%91=43%:%
%:%92=43%:%
%:%93=44%:%
%:%95=46%:%
%:%97=48%:%
%:%98=48%:%
%:%99=49%:%
%:%100=50%:%
%:%102=52%:%
%:%104=54%:%
%:%105=54%:%
%:%106=55%:%
%:%113=57%:%
%:%125=59%:%
%:%126=60%:%
%:%127=61%:%
%:%128=62%:%
%:%129=63%:%
%:%130=64%:%
%:%131=65%:%
%:%132=66%:%
%:%133=67%:%
%:%141=69%:%
%:%142=69%:%
%:%143=70%:%
%:%144=70%:%
%:%145=71%:%
%:%146=71%:%
%:%147=72%:%
%:%148=72%:%
%:%149=72%:%
%:%150=73%:%
%:%151=73%:%
%:%152=74%:%
%:%153=74%:%
%:%154=75%:%
%:%155=75%:%
%:%156=75%:%
%:%157=76%:%
%:%158=76%:%
%:%159=76%:%
%:%160=76%:%
%:%161=77%:%
%:%162=77%:%
%:%163=78%:%
%:%164=78%:%
%:%165=78%:%
%:%166=79%:%
%:%167=79%:%
%:%168=80%:%
%:%169=80%:%
%:%170=81%:%
%:%171=81%:%
%:%172=81%:%
%:%173=82%:%
%:%174=82%:%
%:%175=82%:%
%:%176=82%:%
%:%177=83%:%
%:%178=83%:%
%:%179=84%:%
%:%180=84%:%
%:%181=85%:%
%:%182=85%:%
%:%183=85%:%
%:%184=85%:%
%:%185=86%:%
%:%186=86%:%
%:%187=87%:%
%:%188=87%:%
%:%189=88%:%
%:%190=88%:%
%:%191=88%:%
%:%192=89%:%
%:%193=89%:%
%:%194=89%:%
%:%195=89%:%
%:%196=90%:%
%:%197=90%:%
%:%198=91%:%
%:%208=93%:%
%:%216=95%:%
%:%217=95%:%
%:%218=96%:%
%:%219=96%:%
%:%220=96%:%
%:%229=98%:%
%:%237=100%:%
%:%238=100%:%
%:%239=101%:%
%:%240=101%:%
%:%241=101%:%
%:%250=103%:%
%:%259=105%:%
%:%271=107%:%
%:%273=109%:%
%:%274=109%:%
%:%275=110%:%
%:%276=111%:%
%:%277=112%:%
%:%284=114%:%
%:%296=116%:%
%:%297=117%:%
%:%298=118%:%
%:%306=120%:%
%:%307=120%:%
%:%308=121%:%
%:%309=122%:%
%:%310=123%:%
%:%311=124%:%
%:%312=124%:%
%:%313=125%:%
%:%314=126%:%
%:%315=126%:%
%:%316=126%:%
%:%317=126%:%
%:%326=128%:%
%:%335=130%:%
%:%347=132%:%
%:%349=134%:%
%:%350=134%:%
%:%351=135%:%
%:%352=135%:%
%:%353=135%:%
%:%354=136%:%
%:%355=136%:%
%:%358=138%:%
%:%360=140%:%
%:%361=140%:%
%:%362=141%:%
%:%363=142%:%
%:%365=143%:%
%:%373=145%:%
%:%385=147%:%
%:%386=148%:%
%:%387=149%:%
(*<*)
theory Introduction
  imports 
    HOL.HOL
    HOL.Int
    HOL.Nat
begin
(*>*)

chapter \<open>Introduction\<close>
text \<open>\label{chap:introduction}\<close>

text \<open>Labelled Transition Systems (LTSs) @{cite keller76} are often used to model \emph{reactive systems}, i.e.\@ systems which continuously interact with their environment (e.g.\@ a user) and whose behaviour is largely dependent on this interaction @{cite harel85}.
Roughly, an LTS is a labelled directed graph, whose nodes correspond to states of system and whose edges correspond to transitions between those states.%
\footnote{The topics of this thesis are applicable to any such graphs in an abstract way. However, I will continue to use motivations and terminology derived from the interpretation of LTSs as reactive systems.}

A user interacting with the system can only perceive it in terms of the interactions it reacts to, i.e.\@ the internal state of the system is hidden from the user. This begets a notion of behavioural/observational equivalence: two non-identical systems can exhibit equivalent behaviour as observed by the user. The simplest such equivalence is known as \emph{strong bisimilarity}.

In classical LTSs, a system cannot react to the absence of interaction, as it would be assumed to simply wait for any interaction. Intuitively, however, a system may be equipped with a clock and perform some activity when it has seen no interaction from the user for a specified time. Such a system would not be describable with classical LTS semantics. Amongst these systems are, e.g., systems implementing mutual exclusion protocols \cite{rbs}.

In @{cite vanglabbeek2021failure}, Rob van~Glabbeek introduces Labelled Transition Systems with Time-Outs (\LTSt{}), which allow for modelling such systems as well.
The appertaining equivalence is given in @{cite rbs} as \emph{strong reactive bisimilarity}.

In this thesis, I show that it is possible to reduce checking strong reactive bisimilarity (of processes of an \LTSt{}) to checking strong bisimilarity (of processes of an LTS obtained through a mapping). This is in line with reductions of other behavioural equivalences to strong bisimilarity. For example, a strategy used to reduce \emph{weak bisimilarity} to strong bisimilarity is called \emph{saturation} and is described in @{cite \<open>Section 3.2.5\<close> advBC_algorithmics}.

The reduction of reactive bisimilarity could be of use in the context of automated model checking tools: there are known algorithms for checking equivalences (e.g.\@ see @{cite advBC_algorithmics}) and tools with efficient implementations thereof;%
\footnote{e.g. see LTSmin at \code{\href{https://github.com/utwente-fmt/ltsmin}{github.com/utwente-fmt/ltsmin}}}
instead of implementing an algorithm for checking strong reactive bisimilarity from scratch, an implementation of the reduction would allow the use of these existing implementations.
Moreover, the mapping used for the reduction may aid in the analysis of system specifications utilising \LTSt{}s, by providing a more explicit view at the system.

Another interesting way to examine the behaviour of an LTS is through the use of a modal logic, where formulas describe certain properties and are evaluated on states of an LTS. One such logic is known as Hennessy-Milner logic (HML). 
An extension of HML for evaluation on states of an \LTSt{} is also given in @{cite rbs}; I call it Hennessy-Milner logic with time-outs (\HMLt{}).

For the second main result of this thesis, I show that is possible to reduce formula satisfaction of \HMLt{} on \LTSt{}s to formula satisfaction of HML on LTSs (using another mapping for formulas, along with the mapping from the first reduction).\<close>


section \<open>Isabelle\<close>
text \<open>\label{sec:isabelle}\<close>

text \<open>\emph{Isabelle} is an interactive proof assistant and Isabelle/HOL is an implementation of \emph{higher-order logic} in Isabelle. With it, one can interactively prove propositions of theories that can be formalised in terms of higher-order logic. Many theories have been formalised (and many theorems proven) in Isabelle/HOL and are publicly available.\footnote{see Isabelle's Archive of Formal Proofs at \code{\href{https://www.isa-afp.org}{isa-afp.org}}}

All the main topics of this thesis have been formalised, and all proofs carried out, in Isabelle. Instead of providing all the Isabelle code in the appendix or as supplementary material, I chose to integrate it into the main part of this thesis. A more detailed description of this integration will be given in the next section. In the remainder of this section, the basics of Isabelle will be explained and examples given. An extensive documentation can be found in @{cite isar_ref}.

All formalisations are based on Isabelle/HOL, allowing us to use e.g.\@ quantifiers \<open>\<forall>\<close> and \<open>\<exists>\<close>. \<close>

subsubsection \<open>Simple Definitions\<close>

text \<open>The command \<open>definition\<close> defines a term by establishing an equality, denoted by \<open>\<equiv>\<close>. This term can be a function or a constant (i.e.\@ 0-ary function). Predicates are functions to Boolean values.

Definitions are annotated by their type. As an example, we define the predicate \<open>even\<close>, which maps an integer to a Boolean value.\<close>

definition even :: \<open>int \<Rightarrow> bool\<close>
  where \<open>even n \<equiv> \<exists> m. n = 2 * m\<close>

text \<open>Functions can be defined in uncurried form (e.g.\@ \<open>(int \<times> int) \<Rightarrow> bool\<close>) or in curried form (e.g.\@ \<open>int \<Rightarrow> int \<Rightarrow> bool\<close>). In this thesis, I will usually specify functions in curried form (although at times also in uncurried form). As a very trivial example, we can define equality predicates for integers. The problem of the uncurried version should be evident.\<close>

definition equal_uncurried :: \<open>(int \<times> int) \<Rightarrow> bool\<close>
  where \<open>equal_uncurried pair \<equiv> \<exists> n m. pair = (n, m) \<and> n = m\<close>

definition equal_curried :: \<open>int \<Rightarrow> int \<Rightarrow> bool\<close>
  where \<open>equal_curried n m \<equiv> n = m\<close>

text \<open>We can also use type variables (prefixed with an apostrophe, e.g.\@ \<open>'a\<close>) instead of concrete types to get more abstract terms.\<close>

definition equal_abstract :: \<open>'a \<Rightarrow> 'a \<Rightarrow> bool\<close>
  where \<open>equal_abstract a b \<equiv> a = b\<close>

text \<open>For a less trivial example, we define a predicate \<open>symmetric\<close> that determines whether a given relation is symmetric. An arbitrary homogeneous relation in curried form has the type \<open>'a \<Rightarrow> 'a \<Rightarrow> bool\<close>.\<close>

definition symmetric :: \<open>('a \<Rightarrow> 'a \<Rightarrow> bool) \<Rightarrow> bool\<close>
  where \<open>symmetric R \<equiv> \<forall> a b. R a b \<longrightarrow> R b a\<close>

text \<open>We can also assign notation to a term during the definition, where \<open>_\<close> is a placeholder (and the numbers behind the notation specification represent priorities for parsing, which may be ignored by the reader).\<close>

definition approx :: \<open>int \<Rightarrow> int \<Rightarrow> bool\<close>
  (\<open>_ \<approx> _\<close> [50, 50] 50)
  where \<open>n \<approx> m \<equiv> n=m-1 \<or> n=m \<or> n=m+1\<close>

text \<open>Abbreviations are used the same way as definitions, except that, in order to use the equality established by definitions in proofs, we need to explicitly refer to the definition, whereas abbreviations are always expanded by the proof system. An example a little further down below should clarify the distinction.\<close>

abbreviation reflexive :: \<open>('a \<Rightarrow> 'a \<Rightarrow> bool) \<Rightarrow> bool\<close>
  where \<open>reflexive R \<equiv> \<forall> a. R a a\<close>

subsubsection \<open>Proving Propositions\<close>

text \<open>Propositions are terms of Boolean type without any free variables. Propositions can be given using any of the commands \<open>proposition\<close>, \<open>lemma\<close>, \<open>theorem\<close>, \<open>corollary\<close>, and require a proof.

Since Isabelle is an \emph{interactive} proof assistant, proofs are usually meant to be spelled out in code so as to be readable by humans, and the validity of individual steps is verified by certain automated proof methods (e.g.\@ \<open>simp\<close>, \<open>arith\<close>, \<open>auto\<close>, \<open>fast\<close>, \<open>blast\<close>, \dots). 

As an example, we will show that the relation \<open>approx\<close> is \<open>symmetric\<close>.

Since \<open>symmetric\<close> was defined using the command \<open>definition\<close>, we need to explicitly unfold it, where \<open>symmetric_def\<close> is the fact (about the equality) introduced by the definition.

The method specified after the command \<open>proof\<close> adjusts the proof goal in some way. Ideally, the proof steps should be clear to the reader even without seeing what exactly the automated methods are doing. I have explained each of the steps using comments below.\<close>

proposition\<^marker>\<open>tag (proof) visible\<close> \<open>symmetric approx\<close>
  unfolding symmetric_def
proof (clarify)
  \<comment> \<open>We want to show that for any \<open>n\<close> and \<open>m\<close> with \<open>n \<approx> m\<close>, we have \<open>m \<approx> n\<close>.\<close>
  fix n m
  assume \<open>n \<approx> m\<close>
  \<comment> \<open>Using the definition of \<open>approx\<close>, we now this about \<open>n\<close> and \<open>m\<close>.\<close>
  hence \<open>n=m-1 \<or> n=m \<or> n=m+1\<close> unfolding approx_def .
  thus \<open>m \<approx> n\<close>
  \<comment> \<open>With disjunction elimination, we examine each case in a sub-proof.\<close>
  proof (elim disjE)
    assume \<open>n = m - 1\<close>
    hence \<open>m = n + 1\<close> by arith
    thus \<open>m \<approx> n\<close> unfolding approx_def by blast
  next
    assume \<open>n = m\<close>
    thus \<open>m \<approx> n\<close> using approx_def by blast
  next
    assume \<open>n = m + 1\<close>
    hence \<open>m = n - 1\<close> by arith
    thus \<open>m \<approx> n\<close> using approx_def by blast
  qed
qed

text \<open>This proof was probably more detailed than was necessary. By unfolding the other definition as well, this proposition can be proven directly with the proof method \<open>arith\<close>.\<close>

proposition\<^marker>\<open>tag (proof) visible\<close> \<open>symmetric approx\<close>
  unfolding symmetric_def approx_def by arith

text \<open>To see the difference between definitions and abbreviations, note that the following proposition is provable without unfolding \<open>reflexive_def\<close> (since \<open>reflexive\<close> is an abbreviation, there is no such fact in this context).\<close>

proposition\<^marker>\<open>tag (proof) visible\<close> \<open>reflexive approx\<close>
  unfolding approx_def by auto

text \<open>In practise, of course, one has to strike a balance between transparency/comprehensibility and conciseness of proofs.\<close>

subsubsection \<open>Inductive Definitions\<close>

text \<open>Inductively defined predicates can be given using premise-conclusion pairs and multiple clauses.\<close>

inductive even_ind :: \<open>int \<Rightarrow> bool\<close>
  where
    \<open>even_ind 0\<close>
  | \<open>even_ind n \<Longrightarrow> even_ind (n+2)\<close>

subsubsection \<open>Function Definitions\<close>

text \<open>The command \<open>function\<close> also establishes equalities, but usually in more complex ways, so that, sometimes, it is not obvious whether a function is well-defined. Hence, the command \<open>function\<close> introduces proof obligations to show that the function is, in fact, well-defined. (These proofs are usually easily solved by the automated proof methods.)

The function is then assumed to be partial. The command \<open>termination\<close> introduces proof obligations to show that the function always terminates (and is thus total). For the example below, this proof, again, is trivial.\<close>

function\<^marker>\<open>tag (proof) visible\<close> factorial :: \<open>nat \<Rightarrow> nat\<close>
  where
    \<open>n = 0 \<Longrightarrow> factorial n = 1\<close>
  | \<open>n > 0 \<Longrightarrow> factorial n = n * factorial (n-1)\<close>
  by auto

termination\<^marker>\<open>tag (proof) visible\<close> factorial using "termination" by force

text \<open>After proving well-definedness and totality, we have access to facts about the function that can be used in proofs, e.g.\@ induction principles. More details can be found in \cref{sec:HML}, when we define our first non-trivial \<open>function\<close>.\<close>

subsubsection \<open>Data Types\<close>

text \<open>With the command \<open>datatype\<close>, new types can be defined, possibly in dependence on existing types, by defining a set of (object) constructor functions. For example, we can (re-)define the type of natural numbers.\<close>

datatype natural_number =
  Zero \<comment> \<open>0-ary base constructor\<close>
| Suc \<open>natural_number\<close> \<comment> \<open>unary recursive/inductive constructor\<close>

text \<open>We can define type constructors, i.e.\@ types depending on other types (to be distinguished from the object constructors above) by parameterising the type with type variables.\<close>

datatype ('a)list =
  Empty
| Cons \<open>'a\<close> \<open>('a)list\<close>
\<comment> \<open>binary constructor taking an element of type \<open>'a\<close> and another \<open>('a)list\<close>\<close>

subsubsection \<open>Locales\<close>

text \<open>Locales define a context consisting of type variables, terms, and assumptions. These can be accessed in the entire context. Locales can also be instantiated by specifying concrete types (or type variables from another context) for the type variables, and extended to form new locales. We can reenter the context of a locale later on, using the command \<open>context\<close>.

Instead of giving trivial examples here, readers are referred to the next chapter, where LTSs can be seen as a good example for how locales are used in Isabelle.\<close>


section \<open>How This Thesis is Structured\<close>
text \<open>\label{sec:structure}\<close>

text \<open>This thesis document was generated using the Isabelle document preparation system (see @{cite isa_system}), which generates \LaTeX{} markup from Isabelle code (and, of course, integrates markup written manually). As mentioned in the last section, the Isabelle formalisations are integrated into the main part of this thesis. However, almost all proofs are hidden (and replaced simply by \<open>\<proof>\<close>) and some lemmas excluded. In these cases, an indication of the proof strategy used is given in text. A web version of this thesis, that includes all formalisations, propositions, and proofs, as well as all the text, can be found on GitHub Pages, with one page for each section of this thesis.%
\footnote{Not yet.}

All of the sections of \cref{chap:foundations,chap:reductions} are split in two parts: one containing a prosaic and mathematical description of the topics, and one containing the (documented) formalisation/implementation in Isabelle. I try to clearly distinguish between mathematical structures and their implementation. Although the two are, necessarily, closely related, they are not identical. The former is written in \LaTeX{} math mode in this $italic\;font$ (with $\alpha, \vartheta, \vDash, \xrightarrow{a}, \dots$); the latter is Isabelle code in this \<open>monospaced font\<close> (with \<open>\<alpha>, \<theta>, \<Turnstile>, \<longmapsto>a, \<dots>\<close>).

Contentwise, the remainder of this thesis is split into \nameref{chap:foundations}, where LTSs, bisimilarity, and Hennessy-Milner logic, all without and with time-outs, are discussed an formalised, and \nameref{chap:reductions}, where the two reductions mentioned above are presented in detail and proved.\<close>

(*<*)
end
(*>*)
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="isabelle.css"/>
<title>Theory HM_Logic</title>
</head>


<body>
<div class="head">
<h1>Theory HM_Logic</h1>
</div>

<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> HM_Logic
  <span class="keyword2"><span class="keyword">imports</span></span> 
    <a href="Strong_Bisimilarity.html">Strong_Bisimilarity</a>
    <span class="quoted">"<a href="../../HOL/HOL-Library/Countable_Set_Type.html">HOL-Library.Countable_Set_Type</a>"</span>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">section</span></span> <span class="quoted"><span class="plain_text">‹Hennessy-Milner Logic›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{sec:HML}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In their seminal paper <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> hm85<span class="antiquote"><span class="antiquote">}</span></span></span></span>, Matthew Hennessy and Robin Milner present a modal-logical characterisation of strong bisimilarity (although they do not call it that), by process properties: \enquote{two processes are equivalent if and only if they enjoy the same set of properties.} These properties are expressed as terms of a modal-logical language, consisting merely of (finite) conjunction, negation, and a family of modal possibility operators. This language is known today as Hennessy-Milner logic (HML), with formulas $\varphi$ defined by the following grammar (where $\alpha$ ranges over the set of actions $\Act$):
$$\varphi ::= t\!t \mid \varphi_1 \;\wedge\; \varphi_2 \mid \neg\varphi \mid \langle\alpha\rangle\varphi$$

The semantics (on LTS processes) is given as follows: all processes satisfy $t\!t$, $\varphi_1 \;\wedge\; \varphi_2$ is satisfied if both $\varphi_1$ and $\varphi_2$ are satisfied, $\neg\varphi$ is satisfied if $\varphi$ is not satisfied, and $\langle\alpha\rangle\varphi$ is satisfied by a process if it is possible to do an $\alpha$-transition into a process that satisfies $\varphi$.

<span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> hm85<span class="antiquote"><span class="antiquote">}</span></span></span></span> also contains the proof that this modal-logical characterisation of strong bisimilarity coincides with a characterisation that is effectively the same as the one we saw in \cref{sec:strong_bisimilarity} using strong bisimulations. Although they use different terminology, their result can be summarised as follows: for image-finite LTSs, two processes are strongly bisimilar iff they satisfy the same set of HML formulas. We call this the \emph{modal characterisation} of strong bisimilarity.

Let the \emph{cardinality of conjunction} be the maximally allowed cardinality of sets of formulas conjoined under a conjunction term (for a given variant of HML). For the simple variant above, conjunction has finite cardinality. By allowing for conjunction of arbitrary cardinality (infinitary HML), the modal characterisation of strong bisimilarity can be proved for arbitrary LTSs. This is done in \cref{chap:HML_infinitary}.

In this section, however, conjunction is constrained to be of countable cardinality, as this turned out to be significantly easier to deal with in the upcoming proofs. The modal characterisation of strong bisimilarity, then, works for LTSs that are image-countable, as we shall see below.

Formulas $\varphi$ are given by the following grammar, where $I$ ranges over all subsets of the natural numbers:
$$\varphi ::= \textstyle\bigwedge_{i \in I} \varphi_i \mid \neg\varphi \mid \langle\alpha\rangle\varphi$$

The semantics of HML formulas on LTSs are as above, with the alteration that a process satisfies $\bigwedge_{i \in I} \varphi_i$ iff it satisfies $\varphi_i$ for all $i \in I$.

Additional logical constants can be added as \enquote{syntactic sugar}:
\begin{align*}
    t\!t &amp;\equiv \textstyle\bigwedge_{i \in \emptyset} \varphi_i \\
    f\!\!f &amp;\equiv \neg t\!t \\
    \textstyle\bigvee_{i \in I} \varphi_i &amp;\equiv \neg \textstyle\bigwedge_{i \in I} \neg\varphi_i
\end{align*}›</span></span>


<span class="keyword1"><span class="command">subsection</span></span> <span class="quoted"><span class="plain_text">‹Isabelle›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Syntax›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹By definition of countability, all countable sets of formulas can be given by $\{\varphi_i\}_{i \in I} =: \Phi$ for some $I \subseteq \mathbb{N}$ (then $\bigwedge_{i \in I} \varphi_i$ shall correspond to $\bigwedge \Phi$). Therefore, the following data type (parameterised by the type of actions <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a›</span></span></span></span>) formalises the definition of HML formulas above (<span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>cset›</span></span></span></span> is the type constructor for countable sets; <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>acset›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>rcset›</span></span></span></span> are the type morphisms between the types <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>set›</span></span></span></span> and <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>cset›</span></span></span></span>; more details below).

I abstained from assigning the constructors a more readable symbolic notation because of the ambiguities and name clashes that would ensue in upcoming sections. The symbolic notations after the constructors below are just code comments.
\pagebreak›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>HML_formula <span class="main">=</span>
  HML_conj  <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>HML_formula cset›</span></span> <span class="comment1">― ‹$\bigwedge \Phi$›</span> 
<span class="main">|</span> HML_neg   <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>HML_formula›</span></span> <span class="comment1">― ‹$\neg\varphi$›</span> 
<span class="main">|</span> HML_poss  <span class="quoted"><span class="quoted">‹<span class="tfree">'a</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>HML_formula›</span></span> <span class="comment1">― ‹$\langle\alpha\rangle\varphi$›</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following abbreviations introduce useful constants as syntactic sugar, where <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>cimage HML_neg Φ›</span></span></span></span> corresponds to $\{ \neg\varphi \mid \varphi\in\Phi \}$.›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">HML_true</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>HML_formula›</span></span> <span class="comment1">― ‹$t\!t$›</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">‹<span class="free">HML_true</span> <span class="main">≡</span> HML_conj <span class="main">(</span>acset <span class="main">∅</span><span class="main">)</span>›</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">HML_false</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>HML_formula›</span></span> <span class="comment1">― ‹$f\!\!f$›</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">‹<span class="free">HML_false</span> <span class="main">≡</span> HML_neg HML_true›</span></span>
<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">HML_disj</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>HML_formula cset <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>HML_formula›</span></span> <span class="comment1">― ‹$\bigvee \Phi$›</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">‹<span class="free">HML_disj</span> <span class="free"><span class="bound"><span class="entity">Φ</span></span></span> <span class="main">≡</span> HML_neg <span class="main">(</span>HML_conj <span class="main">(</span>cimage HML_neg <span class="free"><span class="bound"><span class="entity">Φ</span></span></span><span class="main">)</span><span class="main">)</span>›</span></span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Aside: The Type of Countable Sets›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Since sets <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>set›</span></span></span></span> and countable sets <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>cset›</span></span></span></span> are different types in Isabelle, they have different membership relation terms. We introduce the following notation for membership of countable sets.›</span></span>

<span class="keyword1"><span class="command">notation</span></span> cin <span class="main">(</span><span class="quoted">‹_ <span class="keyword1">∈<span class="hidden">⇩</span><sub>c</sub></span> _›</span> <span class="main">[</span>100<span class="main">,</span> 100<span class="main">]</span> 100<span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The following propositions should clarify how the type constructor <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>cset›</span></span></span></span> and its morphisms are used. Note how the first proposition requires the assumption <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>countable X›</span></span></span></span>, whereas the second one does not. ›</span></span>

<span class="keyword1"><span class="command">proposition</span></span> 
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">X</span><span class="main">::</span><span class="quoted"><span class="quoted">‹<span class="tfree">'x</span> set›</span></span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">‹countable <span class="free">X</span>›</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="main">∈</span> <span class="free">X</span>  <span class="main">⟺</span>  <span class="free">x</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>c</sub></span> acset <span class="free">X</span>›</span></span> 
  <span class="keyword1"><span class="command">using</span></span> assms <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cin.rep_eq<span class="main">)</span>
<span class="keyword1"><span class="command">proposition</span></span>
  <span class="keyword2"><span class="keyword">fixes</span></span> <span class="free">X</span><span class="main">::</span><span class="quoted"><span class="quoted">‹<span class="tfree">'x</span> cset›</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">‹<span class="free">x</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>c</sub></span> <span class="free">X</span>  <span class="main">⟺</span>  <span class="free">x</span> <span class="main">∈</span> rcset <span class="free">X</span>›</span></span> 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> cin.rep_eq<span class="main">)</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Semantics›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The semantic satisfaction relation is formalised by the following function. Since the relation is not monotonic (due to negation terms), it cannot be directly defined in Isabelle as an inductive predicate, so we use the <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>function›</span></span></span></span> command instead. This, then, requires us to prove that the function is well-defined (i.e.\@ the function definition completely and compatibly covers all constructors of our data type) and total (i.e.\@ it always terminates). It is easy to see that the former is the case for the function below.
\pagebreak›</span></span>

<span class="keyword1"><span class="command">context</span></span> lts <span class="keyword2"><span class="keyword">begin</span></span>

<span class="keyword1"><span class="command">function</span></span> <span class="entity">HML_sat</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹<span class="tfree">'s</span> <span class="main">⇒</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>HML_formula <span class="main">⇒</span> bool›</span></span>
  <span class="main">(</span><span class="quoted">‹_ <span class="keyword1">⊨</span> _›</span> <span class="main">[</span>50<span class="main">,</span> 50<span class="main">]</span> 50<span class="main">)</span>
  <span class="keyword2"><span class="keyword">where</span></span>
    HML_sat_conj<span class="main">:</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main"><span class="free">⊨</span></span> HML_conj <span class="free"><span class="bound"><span class="entity">Φ</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">φ</span><span class="main">.</span> <span class="bound">φ</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>c</sub></span> <span class="free"><span class="bound"><span class="entity">Φ</span></span></span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main"><span class="free">⊨</span></span> <span class="bound">φ</span><span class="main">)</span>›</span></span> 
  <span class="main">|</span> HML_sat_neg<span class="main">:</span>  <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main"><span class="free">⊨</span></span> HML_neg <span class="free"><span class="bound"><span class="entity">φ</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">¬</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main"><span class="free">⊨</span></span> <span class="free"><span class="bound"><span class="entity">φ</span></span></span><span class="main">)</span>›</span></span> 
  <span class="main">|</span> HML_sat_poss<span class="main">:</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main"><span class="free">⊨</span></span> HML_poss <span class="free"><span class="bound"><span class="entity">α</span></span></span> <span class="free"><span class="bound"><span class="entity">φ</span></span></span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">p'</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main"><span class="free">⟼</span></span><span class="free"><span class="bound"><span class="entity">α</span></span></span> <span class="bound">p'</span> <span class="main">∧</span> <span class="bound">p'</span> <span class="main"><span class="free">⊨</span></span> <span class="free"><span class="bound"><span class="entity">φ</span></span></span><span class="main">)</span>›</span></span>
  <span class="keyword1"><span class="command">using</span></span> HML_formula.exhaust <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">auto</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main">)</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In order to prove that the function always terminates, we need to show that each sequence of recursive invocations reaches a base case%
\footnote{For our satisfaction function, the recursive base case is, of course, the empty conjunction, since
$\forall\varphi.\; \varphi \in \emptyset \longrightarrow p \vDash \varphi$
is a tautology.}
after finitely many steps. We do this by proving that the relation between process-formula pairs given by the recursive definition of the function is (contained within) a well-founded relation.
A relation $R \subseteq X \times X$ is called well-founded if each non-empty subset $X' \subseteq X$ has a minimal element $m$ that is not \enquote{$R$-greater} than any element of $X'$, i.e.\@ $\forall x \in X'.\; (x,m) \notin R$.
A property of well-founded relations is that all descending chains $(x_0, x_1, x_2, \dots)$ (with $(x_i, x_{i+1}) \in R$) starting at any element $x_0 \in X$ are finite. This, then, implies that each sequence of recursive invocations terminates after finitely many steps.

These proofs were inspired by the Isabelle formalisations done in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> weber2021modal<span class="antiquote"><span class="antiquote">}</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">inductive_set</span></span> <span class="entity">HML_wf_rel</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="tfree">'s</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>HML_formula<span class="main">)</span> rel›</span></span> 
  <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">‹<span class="free"><span class="bound"><span class="entity">φ</span></span></span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>c</sub></span> <span class="free"><span class="bound"><span class="entity">Φ</span></span></span> <span class="main">⟹</span> <span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">φ</span></span></span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">,</span> HML_conj <span class="free"><span class="bound"><span class="entity">Φ</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="free">HML_wf_rel</span>›</span></span> 
  <span class="main">|</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">φ</span></span></span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">,</span> HML_neg <span class="free"><span class="bound"><span class="entity">φ</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="free">HML_wf_rel</span>›</span></span> 
  <span class="main">|</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span><span class="main">,</span> <span class="free"><span class="bound"><span class="entity">φ</span></span></span><span class="main">)</span><span class="main">,</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p'</span></span></span><span class="main">,</span> HML_poss <span class="free"><span class="bound"><span class="entity">α</span></span></span> <span class="free"><span class="bound"><span class="entity">φ</span></span></span><span class="main">)</span><span class="main">)</span> <span class="main">∈</span> <span class="free">HML_wf_rel</span>›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> HML_wf_rel_is_wf<span class="main">:</span> <span class="quoted"><span class="quoted">‹wf HML_wf_rel›</span></span> 
  <span class="keyword1"><span class="command">unfolding</span></span> wf_def
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">rule</span> allI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> impI<span class="main"><span class="keyword3">,</span></span> <span class="operator">rule</span> allI<span class="main">)</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">P</span><span class="main">::</span><span class="quoted"><span class="quoted">‹<span class="tfree">'s</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>HML_formula <span class="main">⇒</span> bool›</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="skolem">t</span><span class="main">::</span><span class="quoted"><span class="quoted">‹<span class="tfree">'s</span> <span class="main">×</span> <span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>HML_formula›</span></span>
  <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">p</span></span> <span class="skolem"><span class="skolem">φ</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">t</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">p</span><span class="main">,</span> <span class="skolem">φ</span><span class="main">)</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">x</span><span class="main">.</span> <span class="main">(</span><span class="main">∀</span><span class="bound">y</span><span class="main">.</span> <span class="main">(</span><span class="bound">y</span><span class="main">,</span> <span class="bound">x</span><span class="main">)</span> <span class="main">∈</span> HML_wf_rel <span class="main">⟶</span> <span class="skolem">P</span> <span class="bound">y</span><span class="main">)</span> <span class="main">⟶</span> <span class="skolem">P</span> <span class="bound">x</span>›</span></span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">P</span> <span class="main">(</span><span class="skolem">p</span><span class="main">,</span> <span class="skolem">φ</span><span class="main">)</span>›</span></span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="skolem">φ</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="skolem">p</span></span><span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">smt</span> <span class="main"><span class="main">(</span></span>verit<span class="main"><span class="main">,</span></span> ccfv_SIG<span class="main"><span class="main">)</span></span> HML_formula.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> HML_formula.distinct<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> HML_formula.inject<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> HML_wf_rel_def case_prodE' cin.rep_eq HML_wf_rel.cases mem_Collect_eq split_conv<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">metis</span> HML_formula.distinct<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span> HML_formula.distinct<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span> HML_formula.inject<span class="main"><span class="main">(</span></span>2<span class="main"><span class="main">)</span></span> HML_wf_rel.cases surj_pair<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">apply</span></span></span></span> <span class="main">(</span><span class="operator">smt</span> <span class="main"><span class="main">(</span></span>verit<span class="main"><span class="main">,</span></span> del_insts<span class="main"><span class="main">)</span></span> HML_formula.distinct<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> HML_formula.distinct<span class="main"><span class="main">(</span></span>5<span class="main"><span class="main">)</span></span> HML_formula.inject<span class="main"><span class="main">(</span></span>3<span class="main"><span class="main">)</span></span> HML_wf_rel.cases case_prodD case_prodE' HML_wf_rel_def mem_Collect_eq<span class="main">)</span>
    <span class="keyword1"><span class="command"><span class="improper"><span class="command">done</span></span></span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">P</span> <span class="skolem">t</span>›</span></span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">t</span> <span class="main">=</span> <span class="main">(</span><span class="skolem">p</span><span class="main">,</span> <span class="skolem">φ</span><span class="main">)</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">termination</span></span><span class="comment1">✐<span class="quoted"><span class="quoted">‹tag <span class="main"><span class="main">(</span></span>proof<span class="main"><span class="main">)</span></span> visible›</span></span></span> <span class="quoted">HML_sat</span> <span class="keyword1"><span class="command">using</span></span> HML_wf_rel_is_wf 
  <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">standard</span><span class="main"><span class="keyword3">,</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> HML_wf_rel.intros<span class="main">)</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>


<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The semantic clauses for our additional constants are now easily derivable.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> HML_sat_top<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">p</span> <span class="main">⊨</span> HML_true<span class="main">)</span> <span class="main">=</span> True›</span></span>
  <span class="keyword1"><span class="command">using</span></span> bot_cset.abs_eq <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">lemma</span></span> HML_sat_bot<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">p</span> <span class="main">⊨</span> HML_false<span class="main">)</span> <span class="main">=</span> False›</span></span>
  <span class="keyword1"><span class="command">using</span></span> HML_sat_top <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>
<span class="keyword1"><span class="command">lemma</span></span> HML_sat_disj<span class="main">:</span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">p</span> <span class="main">⊨</span> HML_disj <span class="free">Φ</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="main">∃</span> <span class="bound">φ</span><span class="main">.</span> <span class="bound">φ</span> <span class="keyword1">∈<span class="hidden">⇩</span><sub>c</sub></span> <span class="free">Φ</span> <span class="main">∧</span> <span class="free">p</span> <span class="main">⊨</span> <span class="bound">φ</span><span class="main">)</span>›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>


<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Modal Characterisation of Strong Bisimilarity›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹First, we introduce HML-equivalence as follows.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">HML_equivalent</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹<span class="tfree">'s</span> <span class="main">⇒</span> <span class="tfree">'s</span> <span class="main">⇒</span> bool›</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">‹<span class="free">HML_equivalent</span> <span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">≡</span> <span class="main">(</span><span class="main">∀</span> <span class="bound">φ</span><span class="main">.</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">p</span></span></span> <span class="main">⊨</span> <span class="bound">φ</span><span class="main">)</span> <span class="main">⟷</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">q</span></span></span> <span class="main">⊨</span> <span class="bound">φ</span><span class="main">)</span><span class="main">)</span>›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Since formulas are closed under negation, the following lemma holds.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> distinguishing_formula<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> HML_equivalent <span class="free">p</span> <span class="free">q</span>›</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∃</span> <span class="bound">φ</span><span class="main">.</span> <span class="free">p</span> <span class="main">⊨</span> <span class="bound">φ</span> <span class="main">∧</span> <span class="main">¬</span> <span class="free">q</span> <span class="main">⊨</span> <span class="bound">φ</span>›</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">from</span></span> assms <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">φ</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">‹<span class="free">p</span> <span class="main">⊨</span> <span class="skolem">φ</span> <span class="main">∧</span> <span class="main">¬</span> <span class="free">q</span> <span class="main">⊨</span> <span class="skolem">φ</span> <span class="main">∨</span> <span class="free">q</span> <span class="main">⊨</span> <span class="skolem">φ</span> <span class="main">∧</span> <span class="main">¬</span> <span class="free">p</span> <span class="main">⊨</span> <span class="skolem">φ</span>›</span></span>
    <span class="keyword1"><span class="command">using</span></span> HML_equivalent_def assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="var"><span class="quoted"><span class="var">?thesis</span></span></span> <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main"><span class="keyword3">,</span></span> <span class="operator">auto</span><span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">‹<span class="free">q</span> <span class="main">⊨</span> <span class="skolem">φ</span>›</span></span> <span class="keyword2"><span class="keyword">and</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="free">p</span> <span class="main">⊨</span> <span class="skolem">φ</span>›</span></span>
    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="free">q</span> <span class="main">⊨</span> <span class="skolem">φ</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="free">q</span> <span class="main">⊨</span> HML_neg <span class="skolem">φ</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="free">p</span> <span class="main">⊨</span> <span class="skolem">φ</span>›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">‹<span class="free">p</span> <span class="main">⊨</span> HML_neg <span class="skolem">φ</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>
    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∃</span> <span class="bound">φ</span><span class="main">.</span> <span class="free">p</span> <span class="main">⊨</span> <span class="bound">φ</span> <span class="main">∧</span> <span class="main">¬</span> <span class="free">q</span> <span class="main">⊨</span> <span class="bound">φ</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹HML-equivalence is clearly symmetrical.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span> HML_equivalent_symm<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">‹HML_equivalent <span class="free">p</span> <span class="free">q</span>›</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">‹HML_equivalent <span class="free">q</span> <span class="free">p</span>›</span></span>
  <span class="keyword1"><span class="command">using</span></span> HML_equivalent_def assms <span class="keyword1"><span class="command">by</span></span> <span class="operator">presburger</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We can now formally prove the modal characterisation of strong bisimilarity, i.e.: two processes are HML-equivalent iff they are strongly bisimilar. The proof follows the strategy from <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> resyst<span class="antiquote"><span class="antiquote">}</span></span></span></span>. I chose to include these proofs in the thesis document, because they translate quite beautifully, in my opinion, and are not so long as to hamper with the flow of reading.

We show the $\Longrightarrow$-case first, by induction over <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>φ›</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span><span class="comment1">✐<span class="quoted"><span class="quoted">‹tag <span class="main"><span class="main">(</span></span>proof<span class="main"><span class="main">)</span></span> visible›</span></span></span> strong_bisimilarity_implies_HM_equivalence<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">‹<span class="free">p</span> <span class="main">↔</span> <span class="free">q</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="free">p</span> <span class="main">⊨</span> <span class="free">φ</span>›</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">‹<span class="free">q</span> <span class="main">⊨</span> <span class="free">φ</span>›</span></span>
  <span class="keyword1"><span class="command">using</span></span> assms
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">induct</span> <span class="quoted"><span class="free">φ</span></span> <span class="quasi_keyword">arbitrary</span><span class="main"><span class="main">:</span></span> <span class="quoted"><span class="free">p</span></span> <span class="quoted"><span class="free">q</span></span><span class="main">)</span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>HML_conj <span class="skolem">Φ</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span> 
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> HML_sat_conj cin.rep_eq<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>HML_neg <span class="skolem">φ</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> HML_sat_neg strongly_bisimilar_symm<span class="main">)</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">case</span></span> <span class="main">(</span>HML_poss <span class="skolem">α</span> <span class="skolem">φ</span><span class="main">)</span>
  <span class="keyword1"><span class="command">then</span></span> <span class="keyword3"><span class="command">show</span></span> <span class="var"><span class="quoted"><span class="var">?case</span></span></span>
    <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">meson</span> HML_sat_poss strongly_bisimilar_step<span class="main"><span class="main">(</span></span>1<span class="main"><span class="main">)</span></span><span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Before we can show the $\Longleftarrow$-case, we need to prove the following lemma: for some binary predicate $P$, if for every element $a$ of a set $A$, there exists an element $x$ such that $P(a,x)$ is true, then we can obtain a set $X$ that contains these $x$ (for all $a \in A$) and has the same cardinality as $A$. 

Since more than one $x$ might exist for each $a$ such that $P(a,x)$ is true, the set
$\{ x \mid a \in A \wedge P(a,x) \}$
might have greater cardinality than $A$. In order to obtain a set $X$ of same cardinality as A, we need to invoke the axiom of choice in our proof.›</span></span>

<span class="keyword1"><span class="command">lemma</span></span><span class="comment1">✐<span class="quoted"><span class="quoted">‹tag <span class="main"><span class="main">(</span></span>proof<span class="main"><span class="main">)</span></span> visible›</span></span></span> obtaining_set<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span> 
    <span class="quoted"><span class="quoted">‹<span class="main">∀</span> <span class="bound">a</span> <span class="main">∈</span> <span class="free">A</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">a</span> <span class="bound">x</span>›</span></span> 
    <span class="quoted"><span class="quoted">‹countable <span class="free">A</span>›</span></span>
  <span class="keyword2"><span class="keyword">obtains</span></span> <span class="free">X</span> <span class="keyword2"><span class="keyword">where</span></span> 
    <span class="quoted"><span class="quoted">‹<span class="main">∀</span> <span class="bound">a</span> <span class="main">∈</span> <span class="free">A</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="free">P</span> <span class="bound">a</span> <span class="bound">x</span>›</span></span> 
    <span class="quoted"><span class="quoted">‹<span class="main">∀</span> <span class="bound">x</span> <span class="main">∈</span> <span class="free">X</span><span class="main">.</span> <span class="main">∃</span> <span class="bound">a</span> <span class="main">∈</span> <span class="free">A</span><span class="main">.</span> <span class="free">P</span> <span class="bound">a</span> <span class="bound">x</span>›</span></span> 
    <span class="quoted"><span class="quoted">‹countable <span class="free">X</span>›</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="comment1">― ‹the <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>SOME›</span></span> operator (Hilbert's selection operator $\varepsilon$) invokes the axiom of choice›</span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">xm</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">xm</span> <span class="main">≡</span> <span class="main">λ</span> <span class="bound">a</span><span class="main">.</span> <span class="keyword1">SOME</span> <span class="bound">x</span><span class="main">.</span> <span class="free">P</span> <span class="bound">a</span> <span class="bound">x</span>›</span></span>
  <span class="keyword3"><span class="command">define</span></span> <span class="skolem"><span class="skolem">X</span></span> <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">X</span> <span class="main">≡</span> <span class="main">{</span><span class="skolem">xm</span> <span class="bound">a</span> <span class="main">|</span> <span class="bound">a</span><span class="main">.</span> <span class="bound">a</span> <span class="main">∈</span> <span class="free">A</span><span class="main">}</span>›</span></span>

  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">a</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="main">∃</span><span class="bound">x</span><span class="main">∈</span><span class="skolem">X</span><span class="main">.</span> <span class="free">P</span> <span class="bound">a</span> <span class="bound">x</span>›</span></span>
    <span class="keyword1"><span class="command">using</span></span> X_def xm_def assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span><span class="comment1">✐<span class="quoted">‹tag proof›</span></span> <span class="main">(</span><span class="operator">metis</span> <span class="main"><span class="main">(</span></span>mono_tags<span class="main"><span class="main">,</span></span> lifting<span class="main"><span class="main">)</span></span> mem_Collect_eq someI<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">x</span> <span class="main">∈</span> <span class="skolem">X</span><span class="main">.</span> <span class="main">∃</span><span class="bound">a</span><span class="main">∈</span><span class="free">A</span><span class="main">.</span> <span class="free">P</span> <span class="bound">a</span> <span class="bound">x</span>›</span></span>
    <span class="keyword1"><span class="command">using</span></span> X_def xm_def assms<span class="main">(</span>1<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span><span class="comment1">✐<span class="quoted">‹tag proof›</span></span> <span class="main">(</span><span class="operator">smt</span> <span class="main"><span class="main">(</span></span>verit<span class="main"><span class="main">,</span></span> best<span class="main"><span class="main">)</span></span> mem_Collect_eq someI_ex<span class="main">)</span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">‹countable <span class="skolem">X</span>›</span></span> 
    <span class="keyword1"><span class="command">using</span></span> X_def xm_def assms<span class="main">(</span>2<span class="main">)</span> <span class="keyword1"><span class="command">by</span></span><span class="comment1">✐<span class="quoted">‹tag proof›</span></span> <span class="main">(</span><span class="operator">simp</span> <span class="quasi_keyword">add</span><span class="main"><span class="main">:</span></span> Setcompr_eq_image<span class="main">)</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We can now show, assuming image-countability of the given LTS, that HML-equivalence is a strong bisimulation. The proof utilises classical contradiction: 
if HML-equivalence were no strong bisimulation, there would be some processes $p$ and $q$ that are HML-equivalent, with $p \xrightarrow{\alpha} p'$ for some $p'$ (i.e.\@ $p' \in \text{Der}(p, \alpha)$), but for all $q' \in \text{Der}(q, \alpha)$, $p'$ and $q'$ are not HML-equivalent. 
Then, for each $q' \in \text{Der}(q, \alpha)$, there would be a distinguishing formula $\varphi_{q'}$ which $p'$ satisfies but $q'$ does not. 
Using our <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>obtaining_set›</span></span></span></span> lemma, we can obtain the set 
$\Phi = \{ \varphi_{q'} \}_{q' \in \text{Der}(q, \alpha)}$, which is countable, since $\text{Der}(q, \alpha)$ is countable, by the image-countability assumption.
Since we allow for conjunction of countable cardinality, $\bigwedge \Phi$ is a valid formula. 
By construction, $p$ can make an $\alpha$-transition into a state that satisfies $\bigwedge \Phi$ 
(i.e.\@ $p \vDash \langle\alpha\rangle \bigwedge \Phi$), whereas q cannot 
(i.e.\@ $q \not\vDash \langle\alpha\rangle \bigwedge \Phi$).
This is a contradiction, since, by assumption, $p$ and $q$ are HML-equivalent. 
Therefore, HML-equivalence must be a strong bisimulation.
\pagebreak›</span></span>

<span class="keyword1"><span class="command">lemma</span></span><span class="comment1">✐<span class="quoted"><span class="quoted">‹tag <span class="main"><span class="main">(</span></span>proof<span class="main"><span class="main">)</span></span> visible›</span></span></span> HML_equivalence_is_SB<span class="main">:</span>
  <span class="keyword2"><span class="keyword">assumes</span></span>
    <span class="quoted"><span class="quoted">‹image_countable›</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span>
    <span class="quoted"><span class="quoted">‹SB HML_equivalent›</span></span>
<span class="keyword1"><span class="command">proof</span></span> <span class="operator">-</span>
  <span class="keyword1"><span class="command">{</span></span>
    <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">p</span> <span class="skolem">q</span> <span class="skolem">p'</span> <span class="skolem">α</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">‹HML_equivalent <span class="skolem">p</span> <span class="skolem">q</span>›</span></span> 
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">p</span> <span class="main"><span class="free">⟼</span></span><span class="skolem">α</span> <span class="skolem">p'</span>›</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">q'</span> <span class="main">∈</span> <span class="keyword1">Der(</span><span class="skolem">q</span><span class="main">,</span> <span class="skolem">α</span><span class="main">)</span><span class="main">.</span> <span class="main">¬</span> HML_equivalent <span class="skolem">p'</span> <span class="bound">q'</span>›</span></span>
    
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted">"exists_φ<span class="hidden">⇘</span><sub>q'</sub><span class="hidden">⇙</span>"</span><span class="main">:</span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">q'</span> <span class="main">∈</span> <span class="keyword1">Der(</span><span class="skolem">q</span><span class="main">,</span> <span class="skolem">α</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="bound">φ</span><span class="main">.</span> <span class="skolem">p'</span> <span class="main">⊨</span> <span class="bound">φ</span> <span class="main">∧</span> <span class="main">¬</span> <span class="bound">q'</span> <span class="main">⊨</span> <span class="bound">φ</span>›</span></span>
      <span class="keyword1"><span class="command">using</span></span> distinguishing_formula <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>

    <span class="keyword1"><span class="command">from</span></span> <span class="quoted"><span class="quoted">‹image_countable›</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">‹countable <span class="keyword1">Der(</span><span class="skolem">q</span><span class="main">,</span> <span class="skolem">α</span><span class="main">)</span>›</span></span> 
      <span class="keyword1"><span class="command">using</span></span> image_countable_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">simp</span>

    <span class="keyword1"><span class="command">from</span></span> obtaining_set<span class="main">[</span>
          <span class="keyword2"><span class="keyword"><span class="operator">where</span></span></span> <span class="var">?A</span> <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">‹<span class="keyword1">Der(</span><span class="skolem">q</span><span class="main">,</span> <span class="skolem">α</span><span class="main">)</span>›</span></span>
            <span class="keyword2"><span class="keyword"><span class="quasi_keyword">and</span></span></span> <span class="var">?P</span> <span class="main"><span class="main">=</span></span> <span class="quoted"><span class="quoted">‹<span class="main">λ</span> <span class="bound">q'</span> <span class="bound">φ</span><span class="main">.</span> <span class="skolem">p'</span> <span class="main">⊨</span> <span class="bound">φ</span> <span class="main">∧</span> <span class="main">¬</span> <span class="bound">q'</span> <span class="main">⊨</span> <span class="bound">φ</span>›</span></span><span class="main">,</span> 
          <span class="operator">OF</span> <span class="quoted">"exists_φ<span class="hidden">⇘</span><sub>q'</sub><span class="hidden">⇙</span>"</span> <span class="quoted"><span class="quoted">‹countable <span class="keyword1">Der(</span><span class="skolem">q</span><span class="main">,</span> <span class="skolem">α</span><span class="main">)</span>›</span></span><span class="main">]</span>
    <span class="keyword3"><span class="command">obtain</span></span> <span class="skolem"><span class="skolem">Φ</span></span> <span class="keyword2"><span class="keyword">where</span></span> *<span class="main">:</span>
      <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">φ</span> <span class="main">∈</span> <span class="skolem">Φ</span><span class="main">.</span> <span class="main">∃</span><span class="bound">q'</span> <span class="main">∈</span> <span class="keyword1">Der(</span><span class="skolem">q</span><span class="main">,</span> <span class="skolem">α</span><span class="main">)</span><span class="main">.</span> <span class="skolem">p'</span> <span class="main">⊨</span> <span class="bound">φ</span> <span class="main">∧</span> <span class="main">¬</span> <span class="bound">q'</span> <span class="main">⊨</span> <span class="bound">φ</span>›</span></span> 
      <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">q'</span> <span class="main">∈</span> <span class="keyword1">Der(</span><span class="skolem">q</span><span class="main">,</span> <span class="skolem">α</span><span class="main">)</span><span class="main">.</span> <span class="main">∃</span><span class="bound">φ</span> <span class="main">∈</span> <span class="skolem">Φ</span><span class="main">.</span> <span class="skolem">p'</span> <span class="main">⊨</span> <span class="bound">φ</span> <span class="main">∧</span> <span class="main">¬</span> <span class="bound">q'</span> <span class="main">⊨</span> <span class="bound">φ</span>›</span></span> 
      <span class="quoted"><span class="quoted">‹countable <span class="skolem">Φ</span>›</span></span>
      <span class="keyword1"><span class="command">by</span></span> <span class="main">(</span><span class="operator">this</span><span class="main"><span class="keyword3">,</span></span> <span class="operator">blast</span><span class="main"><span class="keyword3">+</span></span><span class="main">)</span>
  
    <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">p</span> <span class="main">⊨</span> HML_poss <span class="skolem">α</span> <span class="main">(</span>HML_conj <span class="main">(</span>acset <span class="skolem">Φ</span><span class="main">)</span><span class="main">)</span>›</span></span>
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">p</span> <span class="main"><span class="free">⟼</span></span><span class="skolem">α</span> <span class="skolem">p'</span>›</span></span> *<span class="main">(</span>1<span class="main">,</span>3<span class="main">)</span> HML_sat.simps<span class="main">(</span>1<span class="main">,</span>3<span class="main">)</span>
        acset_inverse mem_Collect_eq cin.rep_eq
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">metis</span>

    <span class="keyword1"><span class="command">moreover</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted"><span class="quoted">‹<span class="main">¬</span> <span class="skolem">q</span> <span class="main">⊨</span> HML_poss <span class="skolem">α</span> <span class="main">(</span>HML_conj <span class="main">(</span>acset <span class="skolem">Φ</span><span class="main">)</span><span class="main">)</span>›</span></span>
      <span class="keyword1"><span class="command">using</span></span> *<span class="main">(</span>2<span class="main">,</span>3<span class="main">)</span> cin.rep_eq 
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">fastforce</span>

    <span class="keyword1"><span class="command">ultimately</span></span> <span class="keyword1"><span class="command">have</span></span> <span class="quoted">False</span> 
      <span class="keyword1"><span class="command">using</span></span> <span class="quoted"><span class="quoted">‹HML_equivalent <span class="skolem">p</span> <span class="skolem">q</span>›</span></span> 
      <span class="keyword1"><span class="command">unfolding</span></span> HML_equivalent_def
      <span class="keyword1"><span class="command">by</span></span> <span class="operator">meson</span>
  <span class="keyword1"><span class="command">}</span></span>

  <span class="comment1">― ‹We showed the case for <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>p ⟼α p'›</span></span>, but not <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>q ⟼α q'›</span></span>.›</span>
  <span class="comment1">― ‹Clearly, this case is covered by the symmetry of HML-equivalence.›</span>
  <span class="keyword1"><span class="command">from</span></span> this <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">‹SB HML_equivalent›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> SB_def 
    <span class="keyword1"><span class="command">using</span></span> HML_equivalent_symm <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\pagebreak
We can now conclude the modal characterisation of strong bisimilarity.›</span></span>
  
<span class="keyword1"><span class="command">theorem</span></span><span class="comment1">✐<span class="quoted"><span class="quoted">‹tag <span class="main"><span class="main">(</span></span>proof<span class="main"><span class="main">)</span></span> visible›</span></span></span> modal_characterisation_of_strong_bisimilarity<span class="main">:</span> 
  <span class="keyword2"><span class="keyword">assumes</span></span> <span class="quoted"><span class="quoted">‹image_countable›</span></span>
  <span class="keyword2"><span class="keyword">shows</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">p</span> <span class="main">↔</span> <span class="free">q</span><span class="main">)</span>  <span class="main">⟺</span>  <span class="main">(</span><span class="main">∀</span> <span class="bound">φ</span><span class="main">.</span> <span class="free">p</span> <span class="main">⊨</span> <span class="bound">φ</span> <span class="main">⟷</span> <span class="free">q</span> <span class="main">⊨</span> <span class="bound">φ</span><span class="main">)</span>›</span></span>
<span class="keyword1"><span class="command">proof</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="free">p</span> <span class="main">↔</span> <span class="free">q</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">∀</span><span class="bound">φ</span><span class="main">.</span> <span class="main">(</span><span class="free">p</span> <span class="main">⊨</span> <span class="bound">φ</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">q</span> <span class="main">⊨</span> <span class="bound">φ</span><span class="main">)</span>›</span></span>
    <span class="keyword1"><span class="command">using</span></span> strong_bisimilarity_implies_HM_equivalence 
      strongly_bisimilar_symm 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">next</span></span>
  <span class="keyword3"><span class="command">show</span></span> <span class="quoted"><span class="quoted">‹<span class="main">∀</span><span class="bound">φ</span><span class="main">.</span> <span class="main">(</span><span class="free">p</span> <span class="main">⊨</span> <span class="bound">φ</span><span class="main">)</span> <span class="main">=</span> <span class="main">(</span><span class="free">q</span> <span class="main">⊨</span> <span class="bound">φ</span><span class="main">)</span> <span class="main">⟹</span> <span class="main">(</span><span class="free">p</span> <span class="main">↔</span> <span class="free">q</span><span class="main">)</span>›</span></span> 
    <span class="keyword1"><span class="command">using</span></span> HML_equivalence_is_SB<span class="main">[</span><span class="operator">OF</span> assms<span class="main">]</span> 
      HML_equivalent_def strongly_bisimilar_def 
    <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹of context lts›</span>
<span class="comment1">(*&lt;*)</span>
<span class="keyword2"><span class="keyword">end</span></span> <span class="comment1">― ‹of theory›</span>
<span class="comment1">(*&gt;*)</span></pre>
</body>

</html>
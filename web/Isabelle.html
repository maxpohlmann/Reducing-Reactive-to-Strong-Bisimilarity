<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">

<head><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><link rel="stylesheet" type="text/css" href="isabelle.css"/>
<title>Theory Isabelle</title>
</head>


<body>
<div class="head">
<h1>Theory Isabelle</h1>
</div>

<pre class="source"><span class="comment1">(*&lt;*)</span>
<span class="keyword1"><span class="command">theory</span></span> Isabelle
  <span class="keyword2"><span class="keyword">imports</span></span> 
    <a href="../../HOL/HOL/HOL.html">HOL.HOL</a>
    <a href="../../HOL/HOL/Int.html">HOL.Int</a>
    <a href="../../HOL/HOL/Nat.html">HOL.Nat</a>
<span class="keyword2"><span class="keyword">begin</span></span>
<span class="comment1">(*&gt;*)</span>

<span class="keyword1"><span class="command">chapter</span></span> <span class="quoted"><span class="plain_text">‹Introduction to Isabelle›</span></span>
<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹\label{chap:isabelle}›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Isabelle is an interactive proof assistant and Isabelle/HOL is an implementation of \emph{higher-order logic} in Isabelle. With it, one can interactively prove propositions about theories that are formalised in terms of higher-order \linebreak logic. Many theories have been formalised (and many theorems proven) in Isabelle/HOL and are publicly available.\footnote{see Isabelle's Archive of Formal Proofs at \code{\href{https://www.isa-afp.org}{isa-afp.org}}}

In this appendix, I will give a short introduction into the most important concepts of Isabelle. For an extensive tutorial, see <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> prog_prove<span class="antiquote"><span class="antiquote">}</span></span></span></span>. A complete documentation can be found in <span class="antiquoted"><span class="antiquoted"><span class="antiquote"><span class="antiquote">@{</span></span><span class="operator"><span class="operator">cite</span></span> isar_ref<span class="antiquote"><span class="antiquote">}</span></span></span></span>.
\vspace{-.3cm}›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Simple Definitions›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The command <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>definition›</span></span></span></span> defines a term by establishing an equality, denoted by <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>≡›</span></span></span></span>. This term can be a function or a constant (i.e.\@ 0-ary function). Predicates are functions to Boolean values.

Definitions are annotated by their type. As an example, we define the predicate <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>even›</span></span></span></span>, which maps an integer to a Boolean value.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">even</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹int <span class="main">⇒</span> bool›</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">‹<span class="free">even</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">≡</span> <span class="main">∃</span> <span class="bound">m</span><span class="main">::</span>int <span class="main">.</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="numeral">2</span> <span class="main">*</span> <span class="bound">m</span>›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Functions can be defined in uncurried form (e.g.\@ <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>(int × int) ⇒ bool›</span></span></span></span>) or in curried form (e.g.\@ <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>int ⇒ int ⇒ bool›</span></span></span></span>). As a very trivial example, we can define equality predicates for integers. Compared to the curried version, the uncurried version does not allow for easy pattern matching. This is why, in this thesis, I usually specify functions in curried form.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">equal_uncurried</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span>int <span class="main">×</span> int<span class="main">)</span> <span class="main">⇒</span> bool›</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">‹<span class="free">equal_uncurried</span> <span class="free"><span class="bound"><span class="entity">pair</span></span></span> <span class="main">≡</span> <span class="main">∃</span> <span class="bound">n</span> <span class="bound">m</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">pair</span></span></span> <span class="main">=</span> <span class="main">(</span><span class="bound">n</span><span class="main">,</span> <span class="bound">m</span><span class="main">)</span> <span class="main">∧</span> <span class="bound">n</span> <span class="main">=</span> <span class="bound">m</span>›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">equal_curried</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹int <span class="main">⇒</span> int <span class="main">⇒</span> bool›</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">‹<span class="free">equal_curried</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">m</span></span></span>›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We can also use type variables (prefixed with an apostrophe, e.g.\@ <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a›</span></span></span></span>) instead of concrete types to get more abstract terms.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">equal_abstract</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹<span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool›</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">‹<span class="free">equal_abstract</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="free"><span class="bound"><span class="entity">b</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">a</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">b</span></span></span>›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹For a less trivial example, we define a predicate <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>symmetric›</span></span></span></span> that determines whether a given relation is symmetric. An arbitrary homogeneous relation in curried form has the type <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>'a ⇒ 'a ⇒ bool›</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">symmetric</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> bool›</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">‹<span class="free">symmetric</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">≡</span> <span class="main">∀</span> <span class="bound">a</span> <span class="bound">b</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="bound">a</span> <span class="bound">b</span> <span class="main">⟶</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="bound">b</span> <span class="bound">a</span>›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We can also assign notation to a term during the definition, where <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>_›</span></span></span></span> is a placeholder (and the numbers behind the notation specification represent priorities for parsing, which may be ignored by the reader).›</span></span>

<span class="keyword1"><span class="command">definition</span></span> <span class="entity">approx</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹int <span class="main">⇒</span> int <span class="main">⇒</span> bool›</span></span>
  <span class="main">(</span><span class="quoted">‹_ <span class="keyword1">≈</span> _›</span> <span class="main">[</span>50<span class="main">,</span> 50<span class="main">]</span> 50<span class="main">)</span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">‹<span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main"><span class="free">≈</span></span> <span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">≡</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">-</span><span class="main">1</span> <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">m</span></span></span> <span class="main">∨</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">=</span><span class="free"><span class="bound"><span class="entity">m</span></span></span><span class="main">+</span><span class="main">1</span>›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Abbreviations are used the same way as definitions, except that, in order to use the equality established by definitions in proofs, we need to explicitly refer to the definition, whereas abbreviations are always expanded internally by the proof system. An example a little further down below should clarify the distinction.›</span></span>

<span class="keyword1"><span class="command">abbreviation</span></span> <span class="entity">reflexive</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="tfree">'a</span> <span class="main">⇒</span> <span class="tfree">'a</span> <span class="main">⇒</span> bool<span class="main">)</span> <span class="main">⇒</span> bool›</span></span>
  <span class="keyword2"><span class="keyword">where</span></span> <span class="quoted"><span class="quoted">‹<span class="free">reflexive</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="main">≡</span> <span class="main">∀</span> <span class="bound">a</span><span class="main">.</span> <span class="free"><span class="bound"><span class="entity">R</span></span></span> <span class="bound">a</span> <span class="bound">a</span>›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Proving Propositions›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Propositions can be stated using any of the commands <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>proposition›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>lemma›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>theorem›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>corollary›</span></span></span></span>, and require a proof.

Since Isabelle is an \emph{interactive} proof assistant, proofs are usually meant to be spelled out in code so as to be readable by humans, and the validity of individual steps is verified by certain automated proof methods (e.g.\@ <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>simp›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>arith›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>auto›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>fast›</span></span></span></span>, <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>blast›</span></span></span></span>, \dots). 

As an example, we will show that the relation <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>approx›</span></span></span></span> is <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>symmetric›</span></span></span></span>.

Since <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>symmetric›</span></span></span></span> was defined using the command <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>definition›</span></span></span></span>, we need to explicitly unfold it, where <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>symmetric_def›</span></span></span></span> is the fact (about the equality) introduced by the definition.

The method specified after the command <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>proof›</span></span></span></span> adjusts the proof goal in some way. Ideally, the proof steps should be clear to the reader even without seeing what exactly the automated methods are doing. I have explained each of the steps using comments below.
\pagebreak›</span></span>

<span class="keyword1"><span class="command">proposition</span></span><span class="comment1">✐<span class="quoted"><span class="quoted">‹tag <span class="main"><span class="main">(</span></span>proof<span class="main"><span class="main">)</span></span> visible›</span></span></span> <span class="quoted"><span class="quoted">‹symmetric approx›</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> symmetric_def
<span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">clarify</span><span class="main">)</span>
  <span class="comment1">― ‹We want to show that for any <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>n›</span></span> and <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>m›</span></span> with <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>n ≈ m›</span></span>, we have <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>m ≈ n›</span></span>.›</span>
  <span class="keyword3"><span class="command">fix</span></span> <span class="skolem">n</span> <span class="skolem">m</span>
  <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">n</span> <span class="main">≈</span> <span class="skolem">m</span>›</span></span>
  <span class="comment1">― ‹Using the definition of <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>approx›</span></span>, we know this about <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>n›</span></span> and <span class="antiquoted"><span class="raw_text"><span class="operator">‹</span>m›</span></span>.›</span>
  <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">n</span><span class="main">=</span><span class="skolem">m</span><span class="main">-</span><span class="main">1</span> <span class="main">∨</span> <span class="skolem">n</span><span class="main">=</span><span class="skolem">m</span> <span class="main">∨</span> <span class="skolem">n</span><span class="main">=</span><span class="skolem">m</span><span class="main">+</span><span class="main">1</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> approx_def <span class="keyword1"><span class="command">.</span></span>
  <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m</span> <span class="main">≈</span> <span class="skolem">n</span>›</span></span>
  <span class="comment1">― ‹With disjunction elimination, we examine each case in a sub-proof.›</span>
  <span class="keyword1"><span class="command">proof</span></span> <span class="main">(</span><span class="operator">elim</span> disjE<span class="main">)</span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">n</span> <span class="main">=</span> <span class="skolem">m</span> <span class="main">-</span> <span class="main">1</span>›</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m</span> <span class="main">=</span> <span class="skolem">n</span> <span class="main">+</span> <span class="main">1</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">arith</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m</span> <span class="main">≈</span> <span class="skolem">n</span>›</span></span> <span class="keyword1"><span class="command">unfolding</span></span> approx_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">n</span> <span class="main">=</span> <span class="skolem">m</span>›</span></span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m</span> <span class="main">≈</span> <span class="skolem">n</span>›</span></span> <span class="keyword1"><span class="command">using</span></span> approx_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">next</span></span>
    <span class="keyword3"><span class="command">assume</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">n</span> <span class="main">=</span> <span class="skolem">m</span> <span class="main">+</span> <span class="main">1</span>›</span></span>
    <span class="keyword1"><span class="command">hence</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m</span> <span class="main">=</span> <span class="skolem">n</span> <span class="main">-</span> <span class="main">1</span>›</span></span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">arith</span>
    <span class="keyword3"><span class="command">thus</span></span> <span class="quoted"><span class="quoted">‹<span class="skolem">m</span> <span class="main">≈</span> <span class="skolem">n</span>›</span></span> <span class="keyword1"><span class="command">using</span></span> approx_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">blast</span>
  <span class="keyword1"><span class="command">qed</span></span>
<span class="keyword1"><span class="command">qed</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹This proof was probably more detailed than was necessary. By unfolding the other definition as well, this proposition can be proven directly with the proof method <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>arith›</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">proposition</span></span><span class="comment1">✐<span class="quoted"><span class="quoted">‹tag <span class="main"><span class="main">(</span></span>proof<span class="main"><span class="main">)</span></span> visible›</span></span></span> <span class="quoted"><span class="quoted">‹symmetric approx›</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> symmetric_def approx_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">arith</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹To see the difference between definitions and abbreviations, note that the following proposition is provable without unfolding <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>reflexive_def›</span></span></span></span> (since <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>reflexive›</span></span></span></span> is an abbreviation, there is no such fact in this context).›</span></span>

<span class="keyword1"><span class="command">proposition</span></span><span class="comment1">✐<span class="quoted"><span class="quoted">‹tag <span class="main"><span class="main">(</span></span>proof<span class="main"><span class="main">)</span></span> visible›</span></span></span> <span class="quoted"><span class="quoted">‹reflexive approx›</span></span>
  <span class="keyword1"><span class="command">unfolding</span></span> approx_def <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹In practice, of course, one has to strike a balance between transparency/comprehensibility and conciseness of proofs.›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Inductive Definitions›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Inductively defined predicates can be given using premise-conclusion pairs and multiple clauses.›</span></span>

<span class="keyword1"><span class="command">inductive</span></span> <span class="entity">even_ind</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹int <span class="main">⇒</span> bool›</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">‹<span class="free">even_ind</span> <span class="main">0</span>›</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">‹<span class="free">even_ind</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">⟹</span> <span class="free">even_ind</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">+</span><span class="numeral">2</span><span class="main">)</span>›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Function Definitions›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹The command <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>function›</span></span></span></span> also establishes equalities, but usually in more complex ways, so that it may not obvious whether a function is well-defined. Hence, the well-definedness needs to be proved explicitly. (These proofs are often solved by the automated proof methods.)

The function is then assumed to be partial. The command <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>termination›</span></span></span></span> introduces proof obligations to show that the function always terminates (and is thus total). For the example below, this is again proved automatically.

After proving well-definedness and totality, we have access to facts about the function that can be used in proofs, e.g.\@ induction principles. More details can be found in \cref{sec:HML}, where we define a non-trivial <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>function›</span></span></span></span>.›</span></span>

<span class="keyword1"><span class="command">function</span></span><span class="comment1">✐<span class="quoted"><span class="quoted">‹tag <span class="main"><span class="main">(</span></span>proof<span class="main"><span class="main">)</span></span> visible›</span></span></span> <span class="entity">factorial</span> <span class="main">::</span> <span class="quoted"><span class="quoted">‹nat <span class="main">⇒</span> nat›</span></span>
  <span class="keyword2"><span class="keyword">where</span></span>
    <span class="quoted"><span class="quoted">‹<span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">0</span> <span class="main">⟹</span> <span class="free">factorial</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="main">1</span>›</span></span>
  <span class="main">|</span> <span class="quoted"><span class="quoted">‹<span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">&gt;</span> <span class="main">0</span> <span class="main">⟹</span> <span class="free">factorial</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">=</span> <span class="free"><span class="bound"><span class="entity">n</span></span></span> <span class="main">*</span> <span class="free">factorial</span> <span class="main">(</span><span class="free"><span class="bound"><span class="entity">n</span></span></span><span class="main">-</span><span class="main">1</span><span class="main">)</span>›</span></span>
  <span class="keyword1"><span class="command">by</span></span> <span class="operator">auto</span>

<span class="keyword1"><span class="command">termination</span></span><span class="comment1">✐<span class="quoted"><span class="quoted">‹tag <span class="main"><span class="main">(</span></span>proof<span class="main"><span class="main">)</span></span> visible›</span></span></span> <span class="quoted">factorial</span> <span class="keyword1"><span class="command">using</span></span> <span class="quoted">"termination"</span> <span class="keyword1"><span class="command">by</span></span> <span class="operator">force</span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Data Types›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹With the command <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>datatype›</span></span></span></span>, new types can be defined, possibly in dependence on existing types, by defining a set of (object) constructor functions. For example, we can (re-)define the type of natural numbers.›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> natural_number <span class="main">=</span>
  Zero <span class="comment1">― ‹0-ary base constructor›</span>
<span class="main">|</span> Suc <span class="quoted"><span class="quoted">‹natural_number›</span></span> <span class="comment1">― ‹unary recursive/inductive constructor›</span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹We can define type constructors, i.e.\@ types depending on other types (to be distinguished from the object constructors above) by parameterising the type with type variables.›</span></span>

<span class="keyword1"><span class="command">datatype</span></span> <span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>list <span class="main">=</span>
  Empty
<span class="main">|</span> Cons <span class="quoted"><span class="quoted">‹<span class="tfree">'a</span>›</span></span> <span class="quoted"><span class="quoted">‹<span class="main">(</span><span class="tfree">'a</span><span class="main">)</span>list›</span></span>

<span class="keyword1"><span class="command">subsubsection</span></span> <span class="quoted"><span class="plain_text">‹Locales›</span></span>

<span class="keyword1"><span class="command">text</span></span> <span class="quoted"><span class="plain_text">‹Locales define a context consisting of type variables, object variables, and assumptions. These can be accessed in the entire context. Locales can be instantiated by specifying concrete types/objects (or variables from another context) for the type/object variables, and extended to form new locales. We can reenter the locale contexts later on, using the command <span class="antiquoted"><span class="raw_text"><span class="antiquoted"><span class="raw_text"><span class="operator"><span class="operator">‹</span></span>context›</span></span></span></span>. \Cref{sec:LTS} provides a good example for how locales are used in Isabelle to formalise linear transition systems.›</span></span>

<span class="comment1">(*&lt;*)</span>
<span class="keyword2"><span class="keyword">end</span></span>
<span class="comment1">(*&gt;*)</span></pre>
</body>

</html>